<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Armory Observer</title>

<style>
/* ===============================
   GLOBAL
================================ */

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: system-ui, sans-serif;
  background: #1c1c1c;
  color: #ddd;
}

h2 {
  margin-bottom: 10px;
}

a {
  color: #74c0fc;
  text-decoration: none;
}
a:hover {
  color: #a5d8ff;
}
a:visited {
  color: #74c0fc;
}

.former {
  color: #999;
  font-style: italic;
}

/* ===============================
   APP LAYOUT
================================ */

#app {
  display: flex;
  min-height: 100vh;
}

/* ===============================
   FILTER SIDEBAR
================================ */

#filterSidebar {
  width: 220px;
  flex-shrink: 0;
  background: #2b2b2b;
  color: #ddd;
  padding: 10px;
  height: 100vh;
  overflow-y: auto;
  position: sticky;
  top: 0;
  font-size: 12px;
}

.filter-section {
  margin-bottom: 14px;
}

.filter-section h3 {
  font-size: 12px;
  margin: 6px 0;
  color: #aaa;
  text-transform: uppercase;
}

.filter-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.filter-item,
.sort-btn {
  padding: 4px 6px;
  cursor: pointer;
  background: #3a3a3a;
  border-radius: 3px;
}

.filter-item:hover,
.sort-btn:hover {
  background: #4a4a4a;
}

.filter-item.active,
.sort-btn.active {
  background: #5c5c5c;
  color: #fff;
}

/* ===============================
   MAIN CONTENT
================================ */

#main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.filter-item.former-player {
  opacity: 0.5;
  font-style: italic;
  /* or color: gray; background-color: #f0f0f0; whatever fits your UI */
}


/* ===============================
   SUMMARIES
================================ */
#summaries {
  display: flex;
  flex-direction: column;
  gap: 0;
  color: #ddd;
}

.summary-header {
  text-align:center;
}



/* ----- Tabs container ----- */
.summary-tabs {
  display: flex;
  gap: 0;                 /* no horizontal spacing between tabs */
  margin: 0;              /* remove vertical spacing between rows */
  overflow: hidden;       /* clip rounded corners properly */
}

/* Specific tab row behavior */
.summary-tabs.category-tabs {
  flex-wrap: nowrap;       /* single row */
}

.summary-tabs.item-tabs {
  flex-wrap: wrap;         /* wrap if too many items */
}

.summary-tabs.action-tabs {
  flex-wrap: nowrap;       /* single row */
}

/* ----- Tab buttons (common for all rows) ----- */
.summary-tabs button.tab {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-basis: 0;          /* allows even distribution */
  flex-grow: 1;           /* stretch to fill parent row */
  font-family: Arial, sans-serif;
  font-size: 12px;
  font-weight: 700;
  padding: 6px 7px;       /* height controlled via padding */
  line-height: 16px;      /* vertical alignment of text */
  color: #fff;
  text-shadow: 0 0 2px #00000080;
  background: linear-gradient(180deg, #666666 0%, #333333 100%);
  border: none;
  outline: none;
  position: relative;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  border-right: 1px solid #00000040; /* separator */
}

/* Remove right border on last button of each row */
.summary-tabs button.tab:last-child {
  border-right: none;
}


/* ----- Rounded corners ----- */

/* Top row: categories */
.summary-tabs.category-tabs button.tab:first-child {
  border-top-left-radius: 6px;
}
.summary-tabs.category-tabs button.tab:last-child {
  border-top-right-radius: 6px;
}

/* Middle row: items (no rounding) */
.summary-tabs.item-tabs button.tab {
  border-radius: 0;
}

/* Bottom row: actions */
.summary-tabs.action-tabs button.tab:first-child {
  border-bottom-left-radius: 6px;
}
.summary-tabs.action-tabs button.tab:last-child {
  border-bottom-right-radius: 6px;
}

/* ----- Active / Hover states ----- */
.summary-tabs button.tab.active {
  background: linear-gradient(180deg, #222222 0%, #444444 100%);
}

.summary-tabs button.tab:hover {
  background: linear-gradient(180deg, #555555 0%, #444444 100%);
}

.summary-tabs button.tab.active:hover {
  background: linear-gradient(180deg, #222222 0%, #444444 100%);
}

/* Item tabs: stretch but allow wrapping */
.summary-tabs.item-tabs button.tab {
  flex: 1 1 auto;          /* fill available space and wrap */
  text-align: center;
  min-width: 80px;         /* optional minimum width */
}

/* ----- Players ----- */
.summary-players-wrap {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.summary-players-row {
  display: flex;
  flex-wrap: wrap;         /* wrap players to next line */
  gap: 12px;
}

.summary-player {
  white-space: nowrap;     /* keep name + amount together */
  font-size: 11px;
}

.summary-player .player-amount {
  opacity: 0.75;
  margin-left: 2px;
}



/* ===============================
   LOG OUTPUT
================================ */

#output {
  flex: 1;
  overflow-y: auto;
}

.log-list {
  display: flex;
  flex-direction: column;
}

.log-entry {
  display: flex;
  background: #333;
  border-bottom: 1px solid #222;
  box-shadow: inset 0 1px 0 #ffffff1a;
  color: #eee;
  font-size: 13px;
}

.log-entry-inner {
  display: flex;
  flex: 1;
}

/* LEFT: text */
.log-text {
  flex: 1;
  padding: 9px 10px 8px;
  line-height: 16px;
  word-break: break-word;
}

/* RIGHT: timestamp */
.log-time {
  width: 61px;
  font-size: 10px;
  line-height: 13px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: #bbb;
}

/* Action colors */
.log-entry.donated { background: #2f3a2f; }
.log-entry.used { background: #3a2f2f; }
.log-entry.filled { background: #2f353a; }
.log-entry.loaned,
.log-entry.loaned_receive { background: #3a342f; }
.log-entry.returned,
.log-entry.retrieved { background: #2f3a34; }

/* ===============================
   TIME SELECTOR (POPUP)
================================ */

.timeSelector {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #2b2b2b;
  color: #ddd;
  padding: 14px;
  border-radius: 6px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  z-index: 1000;
}

/* Dark backdrop */
.timeSelector::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: -1;
}

.controls {
  margin-bottom: 10px;
}

button {
  margin-left: 0;
}

/* ===============================
   CALENDAR
================================ */

.calendar-container {
  display: flex;
  gap: 20px;
  margin-top: 10px;
}

.calendar {
  border: 1px solid #444;
  padding: 10px;
  background: #1f1f1f;
}

.calendar-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;
}

.calendar-grid {
  display: grid;
  grid-template-columns: repeat(7, 28px);
  gap: 4px;
}

.calendar-day {
  width: 28px;
  height: 28px;
  text-align: center;
  line-height: 28px;
  border-radius: 4px;
  user-select: none;
}

.available {
  cursor: pointer;
  background: #f5f9ff;
  color: #000;
}

.unavailable {
  background: #444;
  color: #777;
}

.calendar-day.in-range {
  background: #cfe3ff;
}

.calendar-day.range-start,
.calendar-day.range-end {
  background: #4c7cff;
  color: white;
  font-weight: 600;
}

#toggleCalendarBtn {
  position: fixed;       /* Always visible on screen */
  z-index: 1001;         /* above everything else */
  left:100px;
  background: #2b2b2b;
  color: #ddd;
  border: 1px solid #555;
  padding: 6px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
}

#toggleCalendarBtn:hover {
  background: #3a3a3a;
}

</style>
</head>

<body>
<div id="app">
<div id="filterSidebar">
  <div class="filter-section">
    <h3>Sort</h3>
    <button data-sort="desc" class="sort-btn active">Old to New</button>
    <button data-sort="asc" class="sort-btn">New to Old</button>
  </div>

  <div class="filter-section">
    <h3>Players</h3>
    <div class="filter-list" id="playerFilters">
      <div class="filter-item active" data-player="all">Display All</div>
    </div>
  </div>

  <div class="filter-section">
    <h3>Actions</h3>
    <div class="filter-list" id="actionFilters">
      <!-- populated dynamically -->
    </div>
  </div>

  <div class="filter-section">
    <h3>Item Types</h3>
    <div class="filter-list" id="categoryFilters">
      <!-- populated dynamically -->
    </div>
  </div>
</div>
<button id="toggleCalendarBtn" onclick="toggleCalendar()">Select New Time</button>

<div id="main">
<div id="summaries"></div>
<div id="output"></div>
</div>

<div style="width:280px" class="timeSelector">
<div class="controls">
  <button disabled id="toggleCompareBtn">Compare mode</button>
  <button style="margin-left:28px" id="loadBtn">Load Selected</button>
  
  <span style="display:none" id="selectedRangeText"></span>
</div>




<div id="calendarWrapper">
  <div class="calendar-container" id="primaryCalendars"></div>
  <div class="calendar-container" id="compareCalendars" style="display:none;"></div>
</div>

<div>
  <span>Start: <input type="time" id="startTime" value="00:00"></span>
  <span style="margin-left:15px;">End: <input type="time" id="endTime" value="23:59"></span>
</div>

<div id="comparisonTimes" style="display:none; margin-top:5px;">
  Comparison Start: <input type="time" id="compStartTime" value="00:00">
  Comparison End: <input type="time" id="compEndTime" value="23:59">
</div>

</div>


</div>
<script>
/* ================= CONFIG ================= */
const LOG_BASE = "https://raw.githubusercontent.com/Jeyn-o/Armory_observer/main/logs";
const NAMES_URL = "https://raw.githubusercontent.com/Jeyn-o/OC_Stalker/refs/heads/main/BC_names.JSON";
const GH_API_BASE = "https://api.github.com/repos/Jeyn-o/Armory_observer/contents";

/* ================= STATE ================= */
let nameMap = {};
let comparisonMode = false;

const availability = {
  years: new Set(),
  monthsByYear: new Map(),
  daysByMonth: new Map()
};

const monthNames = [
  "January","February","March","April","May","June",
  "July","August","September","October","November","December"
];

const filters = {
  sort: "desc",
  player: "all",
  actions: new Set(),
  categories: new Set(),
};

let ITEM_CATEGORIES = {}; // from items.json
let PLAYER_NAMES = {};    // from BC_names.JSON

let currentData = {}; //Trimmed data from calendar selection


/* ================= HELPERS ================= */
function makeUTCDate(y,m,d){ return new Date(Date.UTC(y,m,d)); }

let CURRENT_TIME_LABEL = "";
let COMPARE_TIME_LABEL = "";

/*function fmtDate(date) {
  // date is a JS Date object
  return date.toISOString().slice(8, 10) + "/" +
         date.toISOString().slice(5, 7) + "/" +
         date.toISOString().slice(0, 4);
}*/

function fmtDate(date) {
  const weekday = date.toLocaleDateString("en-GB", { weekday: "long" });
  const day     = date.toISOString().slice(8, 10);
  const month   = date.toISOString().slice(5, 7);
  const year    = date.toISOString().slice(0, 4);

  return `${weekday} ${day}.${month}.${year}`;
}

const ACTION_LABELS = {
  donated: "Donated",
  used: "Used",
  filled: "Filled",
  loaned: "Loaned",
  loaned_receive: "Received",
  returned: "Returned",
  retrieved: "Retrieved"
};


// --- ITEM CATEGORY LOOKUP ---
function normalize(s) { return s.trim().toLowerCase(); }

const ITEM_LOOKUP = {};

function buildItemLookup() {
  // Clear old entries
  Object.keys(ITEM_LOOKUP).forEach(k => delete ITEM_LOOKUP[k]);

  for (const [cat, items] of Object.entries(ITEM_CATEGORIES)) {
    for (const item of items) {
      const key = normalize(item);
      if (!ITEM_LOOKUP[key]) ITEM_LOOKUP[key] = [];
      ITEM_LOOKUP[key].push(cat); // store all categories the item belongs to
    }
  }

  console.log("ITEM_LOOKUP ready:", ITEM_LOOKUP);
}



function getItemCategory(itemName) {
  if (!itemName || itemName.startsWith("__")) return ["Other"]; // always return an array
  return ITEM_LOOKUP[normalize(itemName)] || ["Other"];
}




function utcDateRange(from,to){
  const days=[]; const d=new Date(from);
  while(d<=to){ days.push(new Date(d)); d.setUTCDate(d.getUTCDate()+1); }
  return days;
}

function fmtTime(ts){
  const d=new Date(ts*1000);
  return `${d.toISOString().slice(11,16)}<br>${d.toISOString().slice(8,10)}/${d.toISOString().slice(5,7)}`;
}

function getUserName(uid){
  const uidStr = String(uid);
  const names = nameMap[uidStr];
  if(!names || names.length === 0){
    return { label: uidStr, former: false, tooltip: "" };
  }

  const last = names[names.length - 1];
  const isFormer = last === "Former Member";

  const label = isFormer
    ? (names[names.length - 2] ?? uidStr)
    : last;

  // Filter out "Former Member" for tooltip
  const previousNames = names.filter(n => n !== "Former Member");

  return {
    label,
    former: isFormer,
    tooltip: previousNames.length > 1 ? previousNames.join(", ") : ""
  };
}


function daysInUTCMonth(year, monthIndex){
  return new Date(Date.UTC(year, monthIndex + 1, 0)).getUTCDate();
}

function flattenData(data){
  const events = [];

  for(const uid in data){
    for(const action in data[uid]){
      for(const item in data[uid][action]){
        data[uid][action][item].forEach(entry => {
          const [amount, ts, actor] = entry;

          let finalAction = action;

          // Fix miscategorized loaned items
          if(action === "loaned_receive") {
            if(actor == uid) {
              finalAction = "loaned"; // loaned to themselves
            } else {
              finalAction = "loaned_receive"; // actually received from someone else
            }
          }

          events.push({
            user: uid,
            actor: actor ?? null,
            action: finalAction,
            item,
            amount,
            ts
          });
        });
      }
    }
  }

  // newest → oldest
  events.sort((a,b)=>b.ts - a.ts);
  return events;
}



/* ================= TIME FILTERING ================= */
/**
 * Trims merged log JSON by timestamp boundaries
 */
function trimDataByTime(data, fromTs, toTs){
  const out = {};

  for(const uid in data){
    for(const cat in data[uid]){
      for(const item in data[uid][cat]){
        const filtered = data[uid][cat][item]
          .filter(e => e[1] >= fromTs && e[1] <= toTs);

        if(filtered.length){
          out[uid] ??= {};
          out[uid][cat] ??= {};
          out[uid][cat][item] = filtered;
        }
      }
    }
  }
  return out;
}

function buildTimestamp(date, timeStr){
  const [hh,mm] = timeStr.split(":").map(Number);
  const d = new Date(date);
  d.setUTCHours(hh,mm,0,0);
  return Math.floor(d.getTime()/1000);
}

/*  TIME TRIMMER  */
/**
 * Returns a new object filtered to only include entries
 * within the given time range (startTimeArray → endTimeArray)
 * Time arrays are [hour, minute] in UTC
 */
function trimByTime(jsonData, startTimeArray, endTimeArray) {
  const [startH, startM] = startTimeArray;
  const [endH, endM] = endTimeArray;
  const startSec = startH * 3600 + startM * 60;
  const endSec = endH * 3600 + endM * 60;

  const trimmed = {};
  for (const uid in jsonData) {
    trimmed[uid] = {};
    for (const cat in jsonData[uid]) {
      trimmed[uid][cat] = {};
      for (const item in jsonData[uid][cat]) {
        const actions = jsonData[uid][cat][item];
        const filtered = actions.filter(a => {
          // a[1] = timestamp in seconds
          const ts = a[1] % 86400; // seconds since start of day
          return ts >= startSec && ts <= endSec;
        });
        if (filtered.length) {
          trimmed[uid][cat][item] = filtered;
        }
      }
    }
  }
  return trimmed;
}



/* ================= FETCH ================= */
async function loadNames(){
  nameMap = await fetch(NAMES_URL).then(r=>r.json());
}

async function fetchGitHubFolder(path){
  const res = await fetch(`${GH_API_BASE}/${path}`);
  if(!res.ok) throw new Error("GitHub fetch failed");
  return res.json();
}

/* ================= DETECT AVAILABLE DATES ================= */
async function detectAvailableDates() {
  try {
    const url = "https://raw.githubusercontent.com/Jeyn-o/armory_observer/refs/heads/main/index.json";
    const json = await fetch(url).then(r => r.ok ? r.json() : {});

    availability.years = new Set();
    availability.monthsByYear = new Map();
    availability.daysByMonth = new Map();

    for (const yearStr of Object.keys(json).sort()) {
      const monthsObj = json[yearStr];
      const monthSet = new Set();
      availability.years.add(yearStr);

      for (const monthStr of Object.keys(monthsObj).sort()) {
        const daysArr = monthsObj[monthStr];

        // Mark the month as available
        monthSet.add(monthStr);

        // Save all available days
        const daySet = new Set(daysArr.map(d => d.padStart(2, "0")));
        availability.daysByMonth.set(`${yearStr}-${monthStr}`, daySet);
      }

      availability.monthsByYear.set(yearStr, monthSet);
    }

    /*console.log("Available years:", availability.years);
    console.log("Months by year:", availability.monthsByYear);
    console.log("Days by month:", availability.daysByMonth);*/
  } catch (e) {
    console.error("Failed to load availability index.json:", e);
  }
}





/* ================= DATA LOAD ================= */
function mergeInto(target,data){
  for(const uid in data){
    target[uid] ??= {};
    for(const cat in data[uid]){
      target[uid][cat] ??= {};
      for(const item in data[uid][cat]){
        target[uid][cat][item] ??= [];
        target[uid][cat][item].push(...data[uid][cat][item]);
      }
    }
  }
}

// Simple in-memory cache
const logCache = {};

async function loadLogs(from, to){
  const merged = {};
  const days = utcDateRange(from, to);

  // Group days by month
  const byMonth = {};
  for(const d of days){
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,"0");
    const key = `${y}-${m}`;
    byMonth[key] ??= [];
    byMonth[key].push(d);
  }

  for(const monthKey in byMonth){
    const monthDays = byMonth[monthKey];
    const [year, month] = monthKey.split("-").map(Number);
    const dim = new Date(Date.UTC(year, month, 0)).getUTCDate();
    const firstDay = monthDays[0].getUTCDate();
    const lastDay = monthDays[monthDays.length-1].getUTCDate();
    const monthStr = String(month).padStart(2,"0");

    // Full month
if(firstDay === 1 && lastDay === dim){
  const url = `${LOG_BASE}/${year}/${monthStr}/Month.json`;

  if(logCache[url]){
    //console.log(`Loaded Month ${monthStr} FULL from cache.`);
  } else {
    try{
      const data = await fetch(url).then(r=>r.ok?r.json():null);
      if(data){
        logCache[url] = data;
        //console.log(`Fetched Month ${monthStr} FULL from GitHub.`);
      }
    }catch(e){
      console.warn(`Failed to fetch Month ${monthStr}:`, e);
    }
  }

  if(logCache[url]) mergeInto(merged, logCache[url]);
  continue;
}


// Partial month → load only needed DD.json files concurrently
const fetchPromises = monthDays.map(d=>{
  const dayStr = String(d.getUTCDate()).padStart(2,"0");
  const url = `${LOG_BASE}/${year}/${monthStr}/${dayStr}.json`;

  if(logCache[url]){
    //console.log(`Loaded Month ${monthStr} Day ${dayStr} from cache.`);
    return Promise.resolve(logCache[url]);
  }

  return fetch(url)
    .then(r=>r.ok?r.json():null)
    .then(data=>{
      if(data){
        logCache[url] = data;
        //console.log(`Fetched Month ${monthStr} Day ${dayStr} from GitHub.`);
      }
      return data;
    })
    .catch(()=>null);
});


    const results = await Promise.all(fetchPromises);
    results.forEach(data=>{ if(data) mergeInto(merged,data); });
  }

  return merged;
}



/* ================= RENDER ================= */
function renderLogEntry(ev) {
  const row = document.createElement("div");
  row.className = `log-entry ${ev.action} item-${cssSafe(ev.item)}`;
  row.dataset.user = ev.user;
  if (ev.actor) row.dataset.actor = ev.actor;
  row.dataset.action = ev.action;
  row.dataset.item = ev.item;
  row.dataset.amount = ev.amount;
  row.dataset.timestamp = ev.ts;
  row.dataset.rawItem = ev.item;
  //console.log("dataset.item:", row.dataset.item);
  //console.log("dataset.rawItem:", row.dataset.rawItem);

  const inner = document.createElement("div");
  inner.className = "log-entry-inner";

  const text = document.createElement("div");
  text.className = "log-text";
  text.innerHTML = reparse(ev, PLAYER_NAMES);

  const time = document.createElement("div");
  time.className = "log-time";
  const d = new Date(ev.ts * 1000);
  time.innerHTML = `
    <div>${d.toISOString().slice(11,19)}</div>
    <div>${d.toISOString().slice(8,10)}/${d.toISOString().slice(5,7)}/${d.toISOString().slice(2,4)}</div>
  `;

  inner.append(text, time);
  row.appendChild(inner);
  return row;
}


function cssSafe(str){
  return str
    .replace(/\s+/g,"_")
    .replace(/[^a-zA-Z0-9_-]/g,"");
}

function renderLogList(events, container){
  container.innerHTML = "";
  const list = document.createElement("div");
  list.className = "log-list";

  events.forEach(ev => list.appendChild(renderLogEntry(ev)));
  container.appendChild(list);
}

function buildSummaryTree(events) {
  const tree = {};

  events.forEach(ev => {
    const cats = getItemCategory(ev.item); // array of categories
    cats.forEach(cat => { // loop over each
      if (!tree[cat]) tree[cat] = {};
      if (ev.item.startsWith("__")) return;
      if (!tree[cat][ev.item]) tree[cat][ev.item] = {};
      if (!tree[cat][ev.item][ev.action]) tree[cat][ev.item][ev.action] = {};
      const player = getUserName(ev.user).label;
      if (!tree[cat][ev.item][ev.action][player]) tree[cat][ev.item][ev.action][player] = 0;

      tree[cat][ev.item][ev.action][player] += parseInt(ev.amount);
    });
  });

  return tree;
}




function renderSummary(tree, events, timeLabel) {
  const container = document.getElementById("summaries");
  container.innerHTML = "";
  
  console.log("renderSummary: tree:", tree, " events:", events, " timeLabel:", timeLabel); 

  // === HEADER ===
  const header = document.createElement("div");
  header.className = "summary-header";
  header.textContent = timeLabel;
  container.appendChild(header);

  // === CATEGORY TABS ===
  const categoryTabs = document.createElement("div");
  categoryTabs.className = "summary-tabs category-tabs";
  container.appendChild(categoryTabs);

  // === ITEM TABS WRAPPER ===
  const itemTabs = document.createElement("div");
  itemTabs.className = "summary-tabs item-tabs";
  container.appendChild(itemTabs);

  // === ACTION TABS WRAPPER ===
  const actionTabs = document.createElement("div");
  actionTabs.className = "summary-tabs action-tabs";
  container.appendChild(actionTabs);

  // === PLAYERS WRAPPER ===
  const playersWrap = document.createElement("div");
  playersWrap.className = "summary-players-wrap";
  container.appendChild(playersWrap);

  const clearChildren = (el) => { while (el.firstChild) el.removeChild(el.firstChild); };

  const categories = Object.keys(tree).sort();
  categories.forEach((category, cIdx) => {
    const catBtn = document.createElement("button");
    catBtn.className = "tab category-tab";
    catBtn.textContent = category;
    if (cIdx === 0) catBtn.classList.add("active");
    categoryTabs.appendChild(catBtn);

    catBtn.addEventListener("click", () => {
      categoryTabs.querySelectorAll("button").forEach(b => b.classList.remove("active"));
      catBtn.classList.add("active");

      // Build item buttons for this category
      clearChildren(itemTabs);
      const items = Object.keys(tree[category]).sort();
      items.forEach((item, iIdx) => {
        const itemBtn = document.createElement("button");
        itemBtn.className = "tab item-tab";
        itemBtn.textContent = item;
        if (iIdx === 0) itemBtn.classList.add("active");
        itemTabs.appendChild(itemBtn);

        itemBtn.addEventListener("click", () => {
          itemTabs.querySelectorAll("button").forEach(b => b.classList.remove("active"));
          itemBtn.classList.add("active");

          // Build action buttons for this item
          clearChildren(actionTabs);
          const actions = Object.keys(tree[category][item]).sort();
          actions.forEach((action, aIdx) => {
            const users = tree[category][item][action];

            // Calculate total sum
            const totalAmount = Object.values(users).reduce((sum, amt) => sum + amt, 0);

            const actionBtn = document.createElement("button");
            actionBtn.className = "tab action-tab";
            actionBtn.textContent = `${action} (${totalAmount})`;
            if (aIdx === 0) actionBtn.classList.add("active");
            actionTabs.appendChild(actionBtn);

            actionBtn.addEventListener("click", () => {
              actionTabs.querySelectorAll("button").forEach(b => b.classList.remove("active"));
              actionBtn.classList.add("active");

              // Display players sorted by amount descending
              clearChildren(playersWrap);
              const sortedPlayers = Object.entries(users)
                .sort((a, b) => b[1] - a[1]); // [uid, amount]

              const row = document.createElement("div");
              row.className = "summary-players-row";

              sortedPlayers.forEach(([uid, amt]) => {
                const nameObj = getUserName(uid);
                const playerDiv = document.createElement("div");
                playerDiv.className = "summary-player";
                playerDiv.innerHTML = `
                  <span class="player-name ${nameObj.former ? "former" : ""}">${nameObj.label}</span>
                  <span class="player-amount">(${amt})</span>
                `;
                if (nameObj.tooltip) playerDiv.title = nameObj.tooltip;
                row.appendChild(playerDiv);
              });

              playersWrap.appendChild(row);
            });
          });

          // Auto-click first action
          if (actions.length > 0) actionTabs.querySelector("button").click();
        });
      });

      // Auto-click first item
      if (items.length > 0) itemTabs.querySelector("button").click();
    });
  });

  // Auto-click first category
  if (categories.length > 0) categoryTabs.querySelector("button").click();
}


/**
 * Reparse a log event into a human-readable string with links.
 * @param {Object} ev - The log event object
 * @param {Object} usernameMap - The BC_names JSON mapping {uid: [names]}
 * @returns {string} - Formatted HTML string
 */
function reparse(ev, usernameMap) {
  // Use the global getUserName()
  const userNameObj = getUserName(ev.user); 
  const userName = userNameObj.label;

  let text = `<a href="https://www.torn.com/profiles.php?XID=${ev.user}">${userName}</a> `;

  switch (ev.action) {
    case "used":
      text += `used one of the faction's ${ev.item} items`;
      break;
    case "filled":
      text += `filled one of the faction's ${ev.item} items`;
      break;
    case "donated":
      text += `deposited ${ev.amount} × ${ev.item}`;
      break;
    case "loaned":
      text += `loaned ${ev.amount} × ${ev.item} to themselves from the faction armory`;
      break;
    case "loaned_receive":
      const sender = getUserName(ev.actor);
      text += `received ${ev.amount} × ${ev.item} from <a href="https://www.torn.com/profiles.php?XID=${ev.actor}">${sender.label}</a>`;
      break;
    case "returned":
      text += `returned ${ev.amount} × ${ev.item}`;
      break;
    case "retrieved":
      const retriever = getUserName(ev.actor);
      text += `returned ${ev.amount} × ${ev.item} by the will of <a href="https://www.torn.com/profiles.php?XID=${ev.actor}">${retriever.label}</a>`;
      break;
    default:
      text += ev.action; // fallback
  }

  return text;
}


function summaryPerPlayer(data, player) {
  const summaryContainer = document.getElementById("summaries");
  if (summaryContainer) summaryContainer.innerHTML = "";

  // Same flattening as render()
  const allEvents = flattenData(data);

  // ⬇️ Filter to one player
  const events = allEvents.filter(e => String(e.user) === String(player));

  if (!events.length) return;

  const summaryTree = buildSummaryTree(events, ITEM_CATEGORIES);

  const newLabel = `${CURRENT_TIME_LABEL} -- ${getUserName(player).label}`;

  renderSummary(summaryTree, events, newLabel);
}

function summaryAll(data) {
  const summaryContainer = document.getElementById("summaries");
  if (summaryContainer) summaryContainer.innerHTML = "";

  // Same flattening as render()
  const events = flattenData(data);

  const summaryTree = buildSummaryTree(events, ITEM_CATEGORIES);

  const newLabel = `${CURRENT_TIME_LABEL}`;

  renderSummary(summaryTree, events, newLabel);
}

// === SINGLE CALENDAR RENDER ===
function render(data) {
console.log("DATA:",data);
  const out = document.getElementById("output");
  out.innerHTML = "";

  const events = flattenData(data);
  //console.log("FLATTENED EVENTS", events);


  // === SUMMARY ===
  const summaryContainer = document.getElementById("summaries");
  if (summaryContainer) summaryContainer.innerHTML = "";

  // Build + render structured summary
  const summaryTree = buildSummaryTree(events, ITEM_CATEGORIES);
  
  console.log("render: summaryTree:", summaryTree, " - Made using buildSummaryTree(events, ITEM_CATEGORIES). events:", events, " ITEM_CATEGORIES: ", ITEM_CATEGORIES, ".");
  //if we filter "events" here to be per-player, we maybe get the result already

  renderSummary(
    summaryTree,
    events,
    CURRENT_TIME_LABEL // e.g. "01/10/25 00:00 → 04/10/25 23:59"
  );

  // === LOGS ===
  const logsBox = document.createElement("div");
  renderLogList(events, logsBox);
  out.appendChild(logsBox);

  // === FILTERS (must come AFTER logs) ===
  buildFilterSidebar(logsBox, PLAYER_NAMES, ITEM_CATEGORIES);

  // For console / debugging
  //window._lastEvents = events;
}


// === COMPARISON RENDER (SIDE-BY-SIDE) ===
function renderCompare(primaryData, compareData) {
  const out = document.getElementById("output");
  out.innerHTML = "";

  const leftEvents = flattenData(primaryData);
  const rightEvents = flattenData(compareData);

  // === SUMMARY BOXES ===
  const summaryContainer = document.getElementById("summaries");
  if (summaryContainer) summaryContainer.innerHTML = "";

  const leftSummary = document.createElement("div");
  const rightSummary = document.createElement("div");

  renderCompactSummary(buildSummaryTree(leftEvents), leftSummary);
  renderCompactSummary(buildSummaryTree(rightEvents), rightSummary);

  const compareSummaryContainer = document.createElement("div");
  compareSummaryContainer.style.display = "flex";
  compareSummaryContainer.style.gap = "10px"; // optional spacing
  compareSummaryContainer.append(leftSummary, rightSummary);

  if (summaryContainer) summaryContainer.appendChild(compareSummaryContainer);

  // === LOGS BOXES ===
  const leftLogs = document.createElement("div");
  const rightLogs = document.createElement("div");

  renderLogList(leftEvents, leftLogs);
  renderLogList(rightEvents, rightLogs);

  const compareContainer = document.createElement("div");
  compareContainer.style.display = "flex";
  compareContainer.style.gap = "10px";

  const leftContainer = document.createElement("div");
  leftContainer.style.flex = "1";
  leftContainer.append(leftLogs);

  const rightContainer = document.createElement("div");
  rightContainer.style.flex = "1";
  rightContainer.append(rightLogs);

  compareContainer.append(leftContainer, rightContainer);
  out.appendChild(compareContainer);

  // === Build filters AFTER logs exist ===
  buildFilterSidebar(compareContainer, PLAYER_NAMES, ITEM_CATEGORIES);

  window._lastEvents = { leftEvents, rightEvents };
}





function renderCompactSummary(summaryTree, container) {
 console.log("NEW renderCompactSummary");
  container.innerHTML = "";

  let activeCategory = null;
  let activeAction = null;

  // === CATEGORY TABS ===
  const categoryRow = document.createElement("div");
  categoryRow.className = "summary-tabs";
  container.appendChild(categoryRow);

  // === ACTION TABS ===
  const actionRow = document.createElement("div");
  actionRow.className = "summary-tabs secondary";
  container.appendChild(actionRow);

  // === PLAYERS ===
  const playersBox = document.createElement("div");
  playersBox.className = "summary-players";
  container.appendChild(playersBox);

  function renderActions(category) {
    actionRow.innerHTML = "";
    playersBox.innerHTML = "";
    activeAction = null;

    Object.keys(summaryTree[category]).forEach(action => {
      const btn = document.createElement("button");
      btn.className = "summary-tab";
      btn.textContent = action;

      btn.onclick = () => {
        actionRow.querySelectorAll(".summary-tab")
          .forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        activeAction = action;
        renderPlayers(category, action);
      };

      actionRow.appendChild(btn);
    });
  }

  function renderPlayers(category, action) {
    playersBox.innerHTML = "";

    const users = summaryTree[category][action];
    Object.keys(users)
      .sort((a, b) => users[b] - users[a])
      .forEach(uid => {
        const nameObj = getUserName(uid);

        const div = document.createElement("div");
        div.className = "summary-player";
        div.innerHTML = `
          <span class="player-name ${nameObj.former ? "former" : ""}">
            ${nameObj.label}
          </span>
          <span class="player-amount">(${users[uid]})</span>
        `;

        if (nameObj.tooltip) div.title = nameObj.tooltip;
        playersBox.appendChild(div);
      });
  }

  // === BUILD CATEGORY BUTTONS ===
  Object.keys(summaryTree).forEach((cat, index) => {
    const btn = document.createElement("button");
    btn.className = "summary-tab";
    btn.textContent = cat;

    btn.onclick = () => {
      categoryRow.querySelectorAll(".summary-tab")
        .forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      activeCategory = cat;
      renderActions(cat);
    };

    categoryRow.appendChild(btn);

    // auto-select first category
    if (index === 0) btn.click();
  });
}


function player_summary(userId){
  const out = document.getElementById("output");
  out.innerHTML = "";

  // assumes last rendered data is available
  if(!window._lastEvents){
    console.warn("No data rendered yet.");
    return;
  }

  const events = window._lastEvents.filter(ev => ev.user == userId);
  const summary = buildSummaryTree(events);

  const title = document.createElement("h3");
  title.textContent = `Player ${userId}`;

  const summaryBox = document.createElement("div");
  renderCompactSummary(summary, summaryBox);

  out.append(title, summaryBox);
}


/* ================= CALENDAR ================= */
function createCalendar(container, label) {
  container.innerHTML = "";
  const cal = document.createElement("div");
  cal.className = "calendar";
  container.appendChild(cal);

  let start = null, end = null;

  function populateYear(select) {
    select.innerHTML = "";
    [...availability.years].sort((a, b) => b - a).forEach(y => {
      const o = document.createElement("option");
      o.value = y;
      o.textContent = y;
      select.appendChild(o);
    });
  }

  function populateMonth(year, select) {
    select.innerHTML = "";
    const monthsSet = availability.monthsByYear.get(year) ?? new Set();
    [...monthsSet].map(m => Number(m) - 1).sort((a, b) => a - b).forEach(m => {
      const o = document.createElement("option");
      o.value = m;
      o.textContent = monthNames[m];
      select.appendChild(o);
    });
  }

  function buildGrid(y, m, grid) {
    grid.innerHTML = "";
    const first = new Date(Date.UTC(y, m, 1)).getUTCDay();
    const days = new Date(Date.UTC(y, m + 1, 0)).getUTCDate();

    // Add empty cells before first day
    for (let i = 0; i < first; i++) grid.appendChild(document.createElement("div"));

    const key = `${y}-${String(m + 1).padStart(2, "0")}`;
    const availableDays = availability.daysByMonth.get(key) ?? new Set();

    for (let d = 1; d <= days; d++) {
      const div = document.createElement("div");
      div.textContent = d;
      div.className = "calendar-day";

      const dayStr = String(d).padStart(2, "0");

      // If the month has all days (or day exists in index), mark as available
      if (availableDays.has(dayStr)) {
        div.classList.add("available");
        div.onclick = () => {
          const clicked = makeUTCDate(y, m, d);
          if (!start) start = clicked;
          else if (!end) {
            if (clicked < start) { end = start; start = clicked; }
            else end = clicked;
          } else { start = clicked; end = null; }
          update();
        };
      } else {
        div.classList.add("unavailable");
      }

      grid.appendChild(div);
    }
  }

  function update() {
    cal.querySelectorAll(".calendar-day").forEach(d => {
      d.classList.remove("in-range", "range-start", "range-end");
      if (!start) return;
      const day = Number(d.textContent);
      if (!day) return;
      const date = makeUTCDate(+year.value, +month.value, day);

      if (date.getTime() === start.getTime()) d.classList.add("range-start");
      if (end && date.getTime() === end.getTime()) d.classList.add("range-end");
      if (end && date > start && date < end) d.classList.add("in-range");
    });

    if (start) {
      selectedRangeText.textContent =
        `${label}: ${start.toISOString().slice(0, 10)}` +
        (end ? ` to ${end.toISOString().slice(0, 10)}` : "");
    }
  }

  const header = document.createElement("div");
  header.className = "calendar-header";
  const month = document.createElement("select");
  const year = document.createElement("select");
  header.append(month, year);
  cal.appendChild(header);

  const grid = document.createElement("div");
  grid.className = "calendar-grid";
  cal.appendChild(grid);

  populateYear(year);
  populateMonth(year.value, month);
  buildGrid(+year.value, +month.value, grid);

  year.onchange = () => { populateMonth(year.value, month); buildGrid(+year.value, +month.value, grid); };
  month.onchange = () => buildGrid(+year.value, +month.value, grid);

  return {
	getRange() {
	  return { from: start, to: end || start };
    },
	reset() {
	  start = null;
      end = null;
      update(); // clears visual selection too
	}
  };

}

function toggleCalendar() {
  const elements = document.querySelectorAll('.timeSelector');

  elements.forEach(el => {
    if (el.style.display === 'none') {
      el.style.display = 'block';
    } else {
      el.style.display = 'none';
    }
  });
}


// ====== FILTER ======
async function loadFilterData() {
  ITEM_CATEGORIES = await fetch("https://raw.githubusercontent.com/Jeyn-o/armory_observer/refs/heads/main/items.json").then(r => r.json());
  PLAYER_NAMES = await fetch("https://raw.githubusercontent.com/Jeyn-o/OC_Stalker/main/BC_names.JSON")
    .then(r => r.json());

  // Build the lookup after items.json is loaded
  buildItemLookup();
  console.log("ITEM_CATEGORIES", ITEM_CATEGORIES);

  // Now that ITEM_LOOKUP is ready, build filters
  //buildCategoryFilters();
  //buildPlayerFilters();
  //buildActionFilters();
}


function buildCategoryFilters() {
  const container = document.getElementById("categoryFilters");
  container.innerHTML = "";

  Object.keys(ITEM_CATEGORIES).forEach(cat => {
    const div = document.createElement("div");
    div.className = "filter-item";
    div.textContent = cat;
    div.onclick = () => toggleFilter(div, filters.categories, cat);
    container.appendChild(div);
  });
}

function buildActionFilters() {
  const actions = new Set();

  document.querySelectorAll(".log-entry").forEach(el => {
    actions.add(el.dataset.action);
  });

  const container = document.getElementById("actionFilters");
  container.innerHTML = "";

  actions.forEach(action => {
    const div = document.createElement("div");
    div.className = "filter-item";
    div.textContent = action;
    div.onclick = () => toggleFilter(div, filters.actions, action);
    container.appendChild(div);
  });
}

function toggleFilter(el, set, value) {
  if (set.has(value)) {
    set.delete(value);
    el.classList.remove("active");
  } else {
    set.add(value);
    el.classList.add("active");
  }
  applyFilters();
}

function applyFilters() {
  const categoryItems = new Set(
    [...filters.categories].flatMap(cat => ITEM_CATEGORIES[cat] || [])
  );

  document.querySelectorAll(".log-entry").forEach(el => {
    let visible = true;

    // Player
    if (filters.player !== "all" && el.dataset.user !== filters.player) {
      visible = false;
    }

    // Action
    if (filters.actions.size && !filters.actions.has(el.dataset.action)) {
      visible = false;
    }

    // Category → item name match
    if (filters.categories.size && !categoryItems.has(el.dataset.item)) {
      visible = false;
    }

    el.style.display = visible ? "flex" : "none";
  });

  sortLogs();
}

document.querySelectorAll(".sort-btn").forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll(".sort-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    filters.sort = btn.dataset.sort;
    sortLogs();
  };
});

function sortLogs() {
  const container = document.getElementById("logContainer");
  const logs = [...container.children];

  logs.sort((a, b) =>
    filters.sort === "desc"
      ? b.dataset.timestamp - a.dataset.timestamp
      : a.dataset.timestamp - b.dataset.timestamp
  );

  logs.forEach(l => container.appendChild(l));
}


// FILTER REBUILDER
function buildFilterSidebar(logContainer, usernameMap, itemsData) {
  const sidebar = document.getElementById("filterSidebar");
  if (!sidebar) return console.error("filterSidebar element not found");

  // Clear existing content
  sidebar.innerHTML = "";

  const logEntries = [...logContainer.querySelectorAll(".log-entry")];

  const filterState = {
    user: "all",
    action: null,
    item: null,
    sort: "desc",
  };

  // --- SORT SECTION ---
  const sortSection = document.createElement("div");
  sortSection.className = "filter-section";
  sortSection.innerHTML = `<h3>Sort</h3>`;
  const newestBtn = document.createElement("button");
  newestBtn.className = "sort-btn active";
  newestBtn.textContent = "Old to New";
  newestBtn.dataset.sort = "desc";
  const oldestBtn = document.createElement("button");
  oldestBtn.className = "sort-btn";
  oldestBtn.textContent = "New to Old";
  oldestBtn.dataset.sort = "asc";

  [newestBtn, oldestBtn].forEach(btn => {
    btn.addEventListener("click", () => {
      filterState.sort = btn.dataset.sort;
      sortSection.querySelectorAll(".sort-btn").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      applyFilters();
    });
  });
  sortSection.append(newestBtn, oldestBtn);
  sidebar.appendChild(sortSection);

  // --- ACTION FILTER (top, always open) ---
  const actionSection = document.createElement("div");
  actionSection.className = "filter-section";
  actionSection.innerHTML = `<h3>Actions</h3>`;
  const actionList = document.createElement("div");
  actionList.className = "filter-list";

  const actionsSet = new Set(logEntries.flatMap(e =>
    e.className.split(/\s+/).filter(c => ["donated","used","filled","loaned","loaned_receive","returned","retrieved"].includes(c))
  ));
  [...actionsSet].sort().forEach(act => {
    const div = document.createElement("div");
    div.className = "filter-item";
    div.dataset.action = act;
    //div.textContent = act;
	div.textContent = ACTION_LABELS[act] ?? act;
    div.addEventListener("click", () => {
      filterState.action = filterState.action === act ? null : act;
      actionList.querySelectorAll(".filter-item").forEach(i => i.classList.remove("active"));
      if(filterState.action) div.classList.add("active");
      applyFilters();
    });
    actionList.appendChild(div);
  });
  actionSection.appendChild(actionList);
  sidebar.appendChild(actionSection);

  // --- ITEM CATEGORY FILTER (collapsible) ---
  const categorySection = document.createElement("div");
  categorySection.className = "filter-section";
  const categoryHeader = document.createElement("h3");
  categoryHeader.textContent = "Item Types";
  categoryHeader.style.cursor = "pointer";
  const categoryList = document.createElement("div");
  categoryList.className = "filter-list";

  // Build list of categories that actually appear in the logs
  const categoriesInLogs = new Set();
  logEntries.forEach(e => {
    const cats = getItemCategory(e.dataset.item); // array
    cats.forEach(cat => categoriesInLogs.add(cat)); // add each individually
  });


  [...categoriesInLogs].sort().forEach(cat => {
  const catDiv = document.createElement("div");
  catDiv.className = "filter-item";
  catDiv.dataset.item = cat;
  catDiv.textContent = cat === "OC_items" ? "OC Items" : cat; // clean label

  catDiv.addEventListener("click", () => {
    filterState.item = filterState.item === cat ? null : cat;
    categoryList.querySelectorAll(".filter-item").forEach(i => i.classList.remove("active"));
    if(filterState.item) catDiv.classList.add("active");
    applyFilters();
  });
  categoryList.appendChild(catDiv);
});


  // Collapse toggle
  categoryHeader.addEventListener("click", () => {
    categoryList.style.display = categoryList.style.display === "none" ? "block" : "none";
  });
  categoryList.style.display = "block"; // start expanded
  categorySection.append(categoryHeader, categoryList);
  sidebar.appendChild(categorySection);

  // --- PLAYER FILTER (collapsible) ---
  const playerSection = document.createElement("div");
  playerSection.className = "filter-section";
  const playerHeader = document.createElement("h3");
  playerHeader.textContent = "Players";
  playerHeader.style.cursor = "pointer";
  const playerList = document.createElement("div");
  playerList.className = "filter-list";
  playerList.id = "playerFilters";

  // "Display All" button
  const displayAll = document.createElement("div");
  displayAll.className = "filter-item active";
  displayAll.dataset.player = "all";
  displayAll.textContent = "Display All";
  displayAll.addEventListener("click", () => {
    filterState.user = "all";
    playerList.querySelectorAll(".filter-item").forEach(item => item.classList.remove("active"));
    displayAll.classList.add("active");
    applyFilters();
  });
  playerList.appendChild(displayAll);

  // individual players
  const usersSet = new Set(logEntries.map(e => e.dataset.user));
  [...usersSet].sort((a,b) => {
    const nameA = getUserName(a).label.toLowerCase();
    const nameB = getUserName(b).label.toLowerCase();
    return nameA.localeCompare(nameB);
  }).forEach(uid => {
    const nameObj = getUserName(uid);
    const div = document.createElement("div");
    div.className = "filter-item";
    div.dataset.player = uid;
    //div.textContent = nameObj.label + (nameObj.former ? " (former)" : "");
	div.textContent = nameObj.label;
	if (nameObj.former) {
	  div.classList.add("former-player");
	}

    if(nameObj.tooltip) div.title = nameObj.tooltip;

    div.addEventListener("click", () => {
      filterState.user = uid;
      playerList.querySelectorAll(".filter-item").forEach(item => item.classList.remove("active"));
      div.classList.add("active");
      applyFilters();
    });
    playerList.appendChild(div);
  });

  // collapse toggle
  playerHeader.addEventListener("click", () => {
    playerList.style.display = playerList.style.display === "none" ? "block" : "none";
  });
  playerList.style.display = "block"; // start expanded
  playerSection.append(playerHeader, playerList);
  sidebar.appendChild(playerSection);

  // --- APPLY FILTERS ---
  function applyFilters() {
  logEntries.forEach(entry => {
    let show = true;

    // User filter
    if (filterState.user !== "all" && entry.dataset.user !== filterState.user) show = false;

    // Action filter
    if (filterState.action && !entry.classList.contains(filterState.action)) show = false;

    // Item category filter
    if (filterState.item) {
      // New: handles multi-category items
	  const entryCats = getItemCategory(entry.dataset.item); // array of categories
	  if (!entryCats.includes(filterState.item)) show = false;

    }

    entry.style.display = show ? "flex" : "none";
  });

  // Sort by timestamp
  logEntries
    .sort((a, b) => {
      const tsA = parseInt(a.dataset.timestamp || "0");
      const tsB = parseInt(b.dataset.timestamp || "0");
      return filterState.sort === "desc" ? tsB - tsA : tsA - tsB;
    })
    .forEach(e => logContainer.appendChild(e));

  // ⬇️ SUMMARY SWITCH (this is the missing link)
  if (filterState.user === "all") {
    summaryAll(currentData);
  } else {
    summaryPerPlayer(currentData, filterState.user);
  }
}

}




/* ================= INIT ================= */
async function initApp() {
  await loadFilterData(); // fetch names and items, build ITEM_LOOKUP
  //const events = flattenData(RAW_DATA); // whatever your source is

  // Now build sidebar and summaries
  const logContainer = document.getElementById("output");
  buildFilterSidebar(logContainer, PLAYER_NAMES, ITEM_CATEGORIES);

  //render(events); // render summaries and logs
}


let primaryCalendar, compareCalendar;

document.getElementById("toggleCompareBtn").onclick = () => {
  comparisonMode = !comparisonMode;
  const c = document.getElementById("compareCalendars");
  c.style.display = comparisonMode ? "flex" : "none";

  const times = document.getElementById("comparisonTimes");
  times.style.display = comparisonMode ? "block" : "none";

  if (comparisonMode && !compareCalendar) {
    compareCalendar = createCalendar(c, "Compare");
  }
};

document.getElementById("loadBtn").onclick = async () => {
  const primary = primaryCalendar.getRange();
  if (!primary.from) return;
  primaryCalendar.reset();

  const startTs = buildTimestamp(primary.from, startTime.value);
  const endTs   = buildTimestamp(primary.to, endTime.value);

  const sameDay =
    primary.from.toISOString().slice(0, 10) ===
    primary.to.toISOString().slice(0, 10);

  CURRENT_TIME_LABEL = sameDay
    ? `${fmtDate(primary.from)} ${startTime.value} - ${endTime.value}`
    : `${fmtDate(primary.from)} ${startTime.value} - ` +
      `${fmtDate(primary.to)} ${endTime.value}`;

/*document.getElementById("loadBtn").onclick = async () => {
  const primary = primaryCalendar.getRange();
  if (!primary.from) return;
  primaryCalendar.reset();

  const startTs = buildTimestamp(primary.from, startTime.value);
  const endTs   = buildTimestamp(primary.to, endTime.value);

  CURRENT_TIME_LABEL =
    `${fmtDate(primary.from)} ${startTime.value} - ` +
    `${fmtDate(primary.to)} ${endTime.value}`;*/

  const raw = await loadLogs(primary.from, primary.to);
  const trimmed = trimDataByTime(raw, startTs, endTs);

  currentData=trimmed;
  render(trimmed);

  if (comparisonMode) {
    const compRange = compareCalendar.getRange();
    const compStartTs = buildTimestamp(compRange.from, compStartTime.value);
    const compEndTs   = buildTimestamp(compRange.to, compEndTime.value);

    COMPARE_TIME_LABEL =
      `${fmtDate(compRange.from)} ${compStartTime.value} - ` +
      `${fmtDate(compRange.to)} ${compEndTime.value}`;

    const rawComp = await loadLogs(compRange.from, compRange.to);
    const trimmedComp = trimDataByTime(rawComp, compStartTs, compEndTs);

    RenderCompare(trimmed, trimmedComp);
  }
  toggleCalendar()
};




(async()=>{
  await loadNames();
  await detectAvailableDates();
  primaryCalendar=createCalendar(
    document.getElementById("primaryCalendars"),
    "Primary"
  );
  initApp(); // call on page load

})();
</script>

</body>
</html>
